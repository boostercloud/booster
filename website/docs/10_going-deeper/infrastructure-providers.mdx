import TerminalWindow from '@site/src/components/TerminalWindow/TerminalWindow'

# Configuring Infrastructure Providers

The providers are different implementations of the Booster runtime to allow Booster applications run on different cloud providers or services. They all implement the same interface, and the main idea behind the providers is that no matter what the developer chooses as backend, they won't need to know anything about the underlying infrastructure.

Currently, the Booster framework provides a fully working provider package:

- **framework-provider-aws-\***
- **framework-provider-azure-\***

Other providers packages are currently under experimental support. Some of the features might be missing:

- **framework-provider-kubernetes-\***

Booster uses sensible defaults, convention over configuration, and code inference to reduce dramatically the amount of configuration needed. However, there are some aspects that can't be inferred (like the application name) or the provider library used for each [environment](environment-configuration).

## Booster configuration

You configure your application by calling the `Booster.configure()` method. There are no restrictions about where you should do this call, but the convention is to do it in your configuration files located in the `src/config` folder. This folder will get automatically generated for you after running the `boost new:project <project-name>` CLI command.

This is an example of a possible configuration:

```typescript
import { Booster } from '@boostercloud/framework-core'
import { BoosterConfig } from '@boostercloud/framework-types'

Booster.configure('pre-production', (config: BoosterConfig): void => {
  config.appName = 'my-app-name'
  config.providerPackage = '@boostercloud/framework-provider-aws'
})
```

The following is the list of the fields you can configure:

- **appName:** This is the name that identifies your application. It will be used for many things, such us prefixing the resources created by the provider. There are certain restrictions regarding the characters you can use: all of them must be lower-cased and can't contain spaces. Two apps with different names are completely independent.

- **providerPackage:** This field contains the name of the provider package that Booster will use when deploying or running your application.

- **enableGraphQLIntrospection** This field allows to enable/disable get information about the GraphQL schema of your application from client side. By default is enabled but it is recommended to disable for security reasons in production applications.

- **assets**: This is an array of _relative_ paths from the root of the project pointing to files and folders with static assets. They will be included among the deployed files to the cloud provider.
  For example, imagine you are using the `dotenv` module so that all the environment variables you have in your `.env` files are loaded into memory in runtime. In order for this to work, you need to include your `.env` files as assets of your project, so that they are included when deploying. Assuming you only have a `.env` file in the root of your project, you should add the following to your configuration:
  ```typescript
  config.assets = ['.env']
  ```

## Providers setup

### AWS Provider setup
In order to dpeloy your app to AWS you only need to provide Booster with the credentials of an AWS account and the
framework will take care of the rest.

:::caution
Booster is free to use, but remember that the resources deployed to your cloud provider
might generate some expenses.

In AWS, all the resources generated by Booster are part of the [AWS free tier](https://aws.amazon.com/free).
When you're not eligible for the free tier, resources are charged on-demand. Deploying a
Booster project and sending a few commands and queries should cost just a few cents.

In any case, make sure to un-deploy your application with the command `boost nuke -e production`
if you're not planning to keep using it.
:::

### Creating an AWS account

If you don't have an AWS account, you can create one by following the [instructions in the AWS documentation](https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/).

### Getting the AWS credentials

Once you have an AWS account, you need to get the credentials that Booster needs to deploy your application. You can follow the [instructions in the AWS documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html#Using_CreateAccessKey) to get them.

Booster needs you to get the following credentials:

- **Access Key ID**
- **Secret Access Key**

Make sure you get them, as they will be needed in the next step.

#### Setting the AWS credentials on Booster

Booster needs to know how to authenticate against your AWS account. For that reason, create a folder called `.aws` under your home folder, and a file inside called `credentials` with this syntax:

```ini title=~/.aws/credentials
[default]
aws_access_key_id=<YOUR ACCESS KEY ID>
aws_secret_access_key=<YOUR SECRET ACCESS KEY>
```
#### AWS Provider configuration

To configure AWS as a provider you need to meet certain prerequisites:

- Check `@boostercloud/framework-provider-aws` is listed in your app `package.json` dependencies.
- Check `@boostercloud/framework-provider-aws-infrastructure` is listed in your app `package.json` devDependencies.
- Check both dependencies are installed, otherwise use `npm install` in the root of your project.

Now go to your `config.ts` file, import the aws provider library and set up your app environment.

```typescript
import { Booster } from '@boostercloud/framework-core'
import { BoosterConfig } from '@boostercloud/framework-types'
import { Provider as AWSProvider } from

Booster.configure('production', (config: BoosterConfig): void => {
  config.appName = 'my-app-name'
  config.providePackage = '@boostercloud/framework-provider-aws'
})
```

Open your terminal and run the deployment command

```sh
boost deploy -e production
```

Now just let the magic happen, Booster will create everything for you and give you back your app ready to use URL. 🚀

## Azure Provider Setup

Booster applications can be deployed to Microsoft Azure. To do so, you need to have an Azure account and to have the Azure CLI installed on your computer.

:::caution

Booster is free to use, but remember that the resources deployed to your cloud provider
might generate some expenses.

In Azure, when you're not eligible for the free tier, resources are charged on-demand. Deploying a
Booster project and sending a few commands and queries should cost just a few cents.

In any case, make sure to un-deploy your application with the command `boost nuke -e production`
if you're not planning to keep using it.
:::

### Creating an Azure account

As mentioned, you need to have an Azure account. If you don't have one, you can create one from [the Microsoft SignUp page](https://azure.microsoft.com/free/). You can also use your existing Microsoft account to create an Azure account.

### Installing the Azure CLI

Once you have created the Azure account, you need to install the Azure CLI on your computer. You can do it by following the instructions on [the official documentation](https://docs.microsoft.com/es-es/cli/azure/install-azure-cli). You may also need to install [jq](https://stedolan.github.io/jq/download/) on your system.

### Azure Provider configuration

To configure Azure as a provider you need to meet certain prerequisites:

- Install [jq](https://stedolan.github.io/jq/download/) in your system.
- Check `@boostercloud/framework-provider-azure` is listed in your app `package.json` dependencies.
- Check `@boostercloud/framework-provider-azure-infrastructure` is listed in your app `package.json` devDependencies.
- Check both dependencies are installed, otherwise use `npm install` in the root of your project.

At this moment you have to log in you Azure account using the Azure CLI with the following command.

```bash
az login
```

Then create a service pricipal running the following command.

```bash
az ad sp create-for-rbac --name <service-principal-name>
```

:::note
Remember to change `<service-principal-name>` for a custom one.
:::

After the service principal is created, create a bash script with the following content. It will set up the necessary environment variables required by the provider in order to work:

```bash
#!/usr/bin/env bash

SP_DISPLAY_NAME="<service-principal-name>" #replace <service-principal-name> with the name of your own SP
REGION="East US" #replace with a region of your choice, see full list here: https://azure.microsoft.com/en-us/global-infrastructure/locations/

export AZURE_APP_ID=$(az ad sp list --display-name ${SP_DISPLAY_NAME} | jq -r '.[].appId')
export AZURE_TENANT_ID=$(az ad sp list --display-name ${SP_DISPLAY_NAME} | jq -r '.[].appOwnerTenantId')
export AZURE_SECRET=$(az ad sp credential reset --name ${AZURE_APP_ID} | jq -r '.password')
export AZURE_SUBSCRIPTION_ID=$(az account show | jq -r '.id')
export REGION
```

:::note
Remember to have [jq](https://stedolan.github.io/jq/download/) installed in your system.
:::

Now go to your `config.ts` file, import the aws provider library and set up your app environment.

```typescript
import { Booster } from '@boostercloud/framework-core'
import { BoosterConfig } from '@boostercloud/framework-types'

Booster.configure('production', (config: BoosterConfig): void => {
  config.appName = 'my-app-name'
  config.providerPackage = '@boostercloud/framework-provider-azure'
})
```

Open your terminal and run the bash file to export you env variables and the deploy command

```bash
source <path-to-your-bash-file> && boost deploy -e production
```

Now just let the magic happen, Booster will create everything for you and give you back your app ready to use URL. 🚀

### Azure synth command

Azure provider implement the experimental **Booster** `synth` command. This command will generate [Terrafom](https://www.terraform.io/) templates from your code. It will also generate needed files to deploy your Booster application using [cdktf](https://learn.hashicorp.com/tutorials/terraform/cdktf).

Running `synth` command, for example `boost synth -e production` will generate following files:

* A file `cdktf.json`: A basic json file to deploy your application using `cdktf`
* A folder `cdktf.out`: with the Terraform templates.

Booster deploy command for Azure will deploy your application using the generated templates.  You don't need to run the `synth` command for deploy your application, the `deploy` command will generate the templates before deploy for you.

Once you have the new files and folders generates you could use `cdktf` to deploy your application if you want to.

### Azure and CI/CD environments

It is possible to deploy your Azure infrastructure using the [Terrafom](https://www.terraform.io/) templates generated by the `synth` command using Terraform executable.

To deploy a **Booster** application using the [Terrafom](https://www.terraform.io/) templates generated by the **Booster** `synth` command:

1. Navigate to
```shell
> cd cdktf.out/stacks/<application name><environment name>
```
2. Run (only the first time)
```shell
> terraform init
```
3. Run
```shell
> terraform plan --out plan
```
4. Run
```shell
> terrafom apply "plan"
```

You could follow similar steps to integrate the Azure **Booster** deploys in your CI/CD environment.

1. Navigate to
```shell
> cd cdktf.out/stacks/<application name><environment name>
```
2. Copy `functionApp.zip` to the destination folder
```shell
> cp functionApp.zip <destination>
```

After copying the files you should have the following structure:

```text
<application>
├── cdktf.out
│   └── stacks
│       └── <application name><environment name>
│           └── cdk.tf.json
```

Now deploy the template:

1. Run (only the first time)
```shell
> terraform init
```
2. Run
```shell
> terraform plan --out plan
```
3. Run
```shell
> terrafom apply "plan"
```

Finally, you need to upload the source code. The main options are ([more info](https://docs.microsoft.com/en-us/azure/azure-functions/deployment-zip-push)):

1. Using az-cli. Run
```shell
> az functionapp deployment source config-zip -g <resource_group> -n \
   <app_name> --src ./functionApp.json
```
2. Using REST APIs. Send a POST request to `https://<app_name>.scm.azurewebsites.net/api/zipdeploy`. Example:
```shell
>  curl -X POST -u <deployment_user> --data-binary @"<zip_file_path>" https://<app_name>.scm.azurewebsites.net/api/zipdeploy
```

:::note
Remember to follow the **Azure Provider** steps in this page to set up your credentials correctly
:::

## Local Provider

All Booster projects come with a local development environment configured by default, so you can test your app before deploying it to the cloud.

You can see the configured local environment in your `src/config/config.ts` file:

```typescript
Booster.configure('local', (config: BoosterConfig): void => {
  config.appName = 'my-store'
  config.providerPackage = '@boostercloud/framework-provider-local'
})
```

In order to start your application using the local provider, use the following command:

```bash
boost start -e local
```

Where `local` is one of your defined environments with the `Booster.configure` call.


## Kubernetes provider

To configure Kubernetes as a provider you need to meet certain prerequisites:

- Config the Kubernetes cluster beforehand in a cloud provider or on-premises.
- Install **kubectl** and connect it to your Kubernetes cluster.
- Install [Helm](https://helm.sh) version 3 or greater.
- Check `@boostercloud/framework-provider-kubernetes` is listed in your app `package.json` dependencies.
- Check `@boostercloud/framework-provider-kubernetes-infrastructure` is listed in your app `package.json` devDependencies.
- Check both dependencies are installed, otherwise use `npm install` in the root of your project.

Now go to your `config.ts` file, import the kubernetes provider library and set up your app environment.

### Working with minikube

[Minikube](https://minikube.sigs.k8s.io/docs/) allows you to use a Kubeneter cluster on your local environment.

Once you have it installed, you just have to make sure that you configure the namespace for the current context. By default, the namespace has the following format: `booster-<app_name>-<environment_name>`. For example, if our app name were “myApp” and the environment “kubernetes-dev”, the namespace config command would be like:

`kubectl config set-context --current --namespace=booster-myApp-kubernetes-dev`

Ready! We can now boost deploy -e kubernetes-dev to deploy our application locally.

```typescript
import { Booster } from '@boostercloud/framework-core'
import { BoosterK8sConfiguration } from '@boostercloud/framework-provider-kubernetes-infrastructure'

Booster.configure('production', (config: BoosterK8sConfiguration): void => {
  config.appName = 'my-app-name'
  config.providerPackage = '@boostercloud/framework-provider-kubernetes'
})
```