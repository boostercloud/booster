"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
const sinon_1 = require("sinon");
const booster_command_dispatcher_1 = require("../../../src/booster-command-dispatcher");
const booster_read_models_reader_1 = require("../../../src/booster-read-models-reader");
const graphql_generator_1 = require("../../../src/services/graphql/graphql-generator");
const framework_types_1 = require("@boostercloud/framework-types");
const expect_1 = require("../../expect");
const graphql_query_generator_1 = require("../../../src/services/graphql/graphql-query-generator");
const graphql_mutation_generator_1 = require("../../../src/services/graphql/graphql-mutation-generator");
const graphql_subcriptions_generator_1 = require("../../../src/services/graphql/graphql-subcriptions-generator");
const faker_1 = require("faker");
const booster_events_reader_1 = require("../../../src/booster-events-reader");
describe('GraphQL generator', () => {
    let mockEnvironmentName;
    let mockConfig;
    beforeEach(() => {
        mockEnvironmentName = faker_1.random.alphaNumeric(10);
        mockConfig = new framework_types_1.BoosterConfig(mockEnvironmentName);
        mockConfig.logLevel = framework_types_1.Level.error;
    });
    afterEach(() => {
        (0, sinon_1.restore)();
    });
    describe('generateSchema', () => {
        let mockQueryTypeName;
        let mockMutationTypeName;
        let mockSubscriptionTypeName;
        let fakeQueryGenerator;
        let fakeMutationGenerator;
        let fakeSubscriptionGenerator;
        beforeEach(() => {
            mockQueryTypeName = faker_1.random.alphaNumeric(10);
            mockMutationTypeName = faker_1.random.alphaNumeric(10);
            mockSubscriptionTypeName = faker_1.random.alphaNumeric(10);
            fakeQueryGenerator = (0, sinon_1.stub)().returns({ name: mockQueryTypeName });
            fakeMutationGenerator = (0, sinon_1.stub)().returns({ name: mockMutationTypeName });
            fakeSubscriptionGenerator = (0, sinon_1.stub)().returns({ name: mockSubscriptionTypeName });
            (0, sinon_1.replace)(graphql_query_generator_1.GraphQLQueryGenerator.prototype, 'generate', fakeQueryGenerator);
            (0, sinon_1.replace)(graphql_mutation_generator_1.GraphQLMutationGenerator.prototype, 'generate', fakeMutationGenerator);
            (0, sinon_1.replace)(graphql_subcriptions_generator_1.GraphQLSubscriptionGenerator.prototype, 'generate', fakeSubscriptionGenerator);
            // Remove the schema generated by previous tests
            const generatorSingleton = graphql_generator_1.GraphQLGenerator;
            delete generatorSingleton.schema;
        });
        it('should call QueryGenerator', () => {
            graphql_generator_1.GraphQLGenerator.generateSchema(mockConfig);
            (0, expect_1.expect)(fakeQueryGenerator).to.have.been.calledOnceWithExactly();
        });
        it('should call MutationGenerator', () => {
            graphql_generator_1.GraphQLGenerator.generateSchema(mockConfig);
            (0, expect_1.expect)(fakeMutationGenerator).to.have.been.calledOnceWithExactly();
        });
        it('should call SubscriptionGenerator', () => {
            graphql_generator_1.GraphQLGenerator.generateSchema(mockConfig);
            (0, expect_1.expect)(fakeSubscriptionGenerator).to.have.been.calledOnceWithExactly();
        });
        it('should return a GraphQL schema', () => {
            const result = graphql_generator_1.GraphQLGenerator.generateSchema(mockConfig);
            const expectedTypes = {
                _queryType: {
                    name: mockQueryTypeName,
                },
                _mutationType: {
                    name: mockMutationTypeName,
                },
                _subscriptionType: {
                    name: mockSubscriptionTypeName,
                },
            };
            (0, expect_1.expect)(result).to.deep.contain(expectedTypes);
        });
    });
    describe('resolvers', () => {
        let mockType;
        let mockRequestId;
        let mockEmail;
        let mockRole;
        let mockFetchResult;
        let mockResolverContext;
        let mockResolverInfo;
        let asyncIteratorStub;
        let mockAsyncIteratorResult;
        beforeEach(() => {
            mockType = faker_1.random.arrayElement([Boolean, String, Number]);
            mockRequestId = faker_1.random.uuid();
            mockEmail = faker_1.internet.email();
            mockRole = faker_1.random.alphaNumeric(10);
            mockFetchResult = [];
            for (let i = 0; i < faker_1.random.number({ min: 1, max: 10 }); i++) {
                mockFetchResult.push({
                    id: faker_1.random.uuid(),
                    testKey: faker_1.random.number(),
                });
            }
            mockAsyncIteratorResult = faker_1.lorem.word();
            asyncIteratorStub = (0, sinon_1.stub)().returns(mockAsyncIteratorResult);
            mockResolverContext = {
                requestID: mockRequestId,
                responseHeaders: {},
                user: {
                    username: mockEmail,
                    roles: [mockRole],
                    claims: {},
                },
                operation: {
                    query: faker_1.random.alphaNumeric(),
                },
                pubSub: {
                    asyncIterator: (x) => asyncIteratorStub(x),
                },
                storeSubscriptions: false,
                context: {
                    request: {
                        headers: {
                            authorization: 'Bearer 123',
                        },
                        body: {
                            query: 'Test query',
                        },
                    },
                    rawContext: {},
                },
            };
            mockResolverInfo = {
                fieldNodes: [],
            };
        });
        describe('readModelResolverBuilder', () => {
            let fakeSearch;
            let returnedFunction;
            beforeEach(() => {
                fakeSearch = (0, sinon_1.stub)().resolves(mockFetchResult);
                (0, sinon_1.replace)(booster_read_models_reader_1.BoosterReadModelsReader.prototype, 'search', fakeSearch);
                returnedFunction = graphql_generator_1.GraphQLGenerator.readModelResolverBuilder(mockType);
            });
            it('should call fetch with expected payload', async () => {
                const expectedFetchPayload = {
                    currentUser: {
                        username: mockEmail,
                        roles: [mockRole],
                        claims: {},
                    },
                    filters: {},
                    sortBy: {},
                    requestID: mockRequestId,
                    class: mockType,
                    className: mockType.name,
                    limit: undefined,
                    afterCursor: undefined,
                    paginatedVersion: false,
                    version: 1,
                    select: undefined,
                };
                await returnedFunction('', {}, mockResolverContext, { fieldNodes: [] });
                (0, expect_1.expect)(fakeSearch).to.have.been.calledOnceWithExactly(expectedFetchPayload);
            });
            it('should return expected result', async () => {
                const result = await returnedFunction('', {}, mockResolverContext, mockResolverInfo);
                (0, expect_1.expect)(result).to.be.deep.equal(mockFetchResult);
            });
        });
        describe('readModelByIDResolverBuilder', () => {
            class SomeReadModel {
                constructor(id, timestamp) {
                    this.id = id;
                    this.timestamp = timestamp;
                }
            }
            context('when the read model is non sequenced', () => {
                const config = new framework_types_1.BoosterConfig('test');
                it('builds a function that perform requests by id', async () => {
                    const toReadModelByIdRequestEnvelopeSpy = (0, sinon_1.spy)(graphql_generator_1.GraphQLGenerator, 'toReadModelByIdRequestEnvelope');
                    const fakeFindById = (0, sinon_1.fake)();
                    (0, sinon_1.replace)(graphql_generator_1.GraphQLGenerator.readModelsReader, 'findById', fakeFindById);
                    const returnedFunction = graphql_generator_1.GraphQLGenerator.readModelByIDResolverBuilder(config, SomeReadModel);
                    const fakeArgs = { id: '42' };
                    const fakeUser = { a: 'user' };
                    const fakeContext = { user: fakeUser, requestID: '314' };
                    await returnedFunction({}, fakeArgs, fakeContext, {});
                    (0, expect_1.expect)(toReadModelByIdRequestEnvelopeSpy).to.have.been.calledOnceWith(SomeReadModel, fakeArgs, fakeContext);
                    const envelope = toReadModelByIdRequestEnvelopeSpy.returnValues[0];
                    (0, expect_1.expect)(envelope).to.have.property('currentUser', fakeUser);
                    (0, expect_1.expect)(envelope).to.have.property('requestID', '314');
                    (0, expect_1.expect)(envelope).to.have.property('class', SomeReadModel);
                    (0, expect_1.expect)(envelope).to.have.property('className', 'SomeReadModel');
                    (0, expect_1.expect)(envelope.key).to.be.deep.equal({ id: '42' });
                    (0, expect_1.expect)(envelope.key.sequenceKey).to.be.undefined;
                    (0, expect_1.expect)(envelope).to.have.property('version', 1);
                    (0, expect_1.expect)(fakeFindById).to.have.been.calledOnceWith(envelope);
                });
            });
            context('when the read model is sequenced', () => {
                const config = new framework_types_1.BoosterConfig('test');
                config.readModelSequenceKeys['SomeReadModel'] = 'timestamp';
                it('builds a function that perform requests by id and sequence key', async () => {
                    const toReadModelByIdRequestEnvelopeSpy = (0, sinon_1.spy)(graphql_generator_1.GraphQLGenerator, 'toReadModelByIdRequestEnvelope');
                    const fakeFindById = (0, sinon_1.fake)();
                    (0, sinon_1.replace)(graphql_generator_1.GraphQLGenerator.readModelsReader, 'findById', fakeFindById);
                    const returnedFunction = graphql_generator_1.GraphQLGenerator.readModelByIDResolverBuilder(config, SomeReadModel);
                    const fakeArgs = { id: '42', timestamp: '1000' };
                    const fakeUser = { a: 'user' };
                    const fakeContext = { user: fakeUser, requestID: '314' };
                    await returnedFunction({}, fakeArgs, fakeContext, {});
                    (0, expect_1.expect)(toReadModelByIdRequestEnvelopeSpy).to.have.been.calledOnceWith(SomeReadModel, fakeArgs, fakeContext, 'timestamp');
                    const envelope = toReadModelByIdRequestEnvelopeSpy.returnValues[0];
                    (0, expect_1.expect)(envelope).to.have.property('currentUser', fakeUser);
                    (0, expect_1.expect)(envelope).to.have.property('requestID', '314');
                    (0, expect_1.expect)(envelope).to.have.property('class', SomeReadModel);
                    (0, expect_1.expect)(envelope).to.have.property('className', 'SomeReadModel');
                    (0, expect_1.expect)(envelope.key).to.be.deep.equal({ id: '42', sequenceKey: { name: 'timestamp', value: '1000' } });
                    (0, expect_1.expect)(envelope).to.have.property('version', 1);
                    (0, expect_1.expect)(fakeFindById).to.have.been.calledOnceWith(envelope);
                });
            });
        });
        describe('commandResolverBuilder', () => {
            let mockInput;
            let dispatchCommandStub;
            let returnedFunction;
            beforeEach(() => {
                mockInput = {
                    testObjectKey: faker_1.random.alphaNumeric(10),
                };
                dispatchCommandStub = (0, sinon_1.stub)();
                (0, sinon_1.replace)(booster_command_dispatcher_1.BoosterCommandDispatcher.prototype, 'dispatchCommand', dispatchCommandStub);
                returnedFunction = graphql_generator_1.GraphQLGenerator.commandResolverBuilder(mockType);
            });
            it('should call dispatchCommand with expected input', async () => {
                await returnedFunction('', {
                    input: mockInput,
                }, mockResolverContext, mockResolverInfo);
                (0, expect_1.expect)(dispatchCommandStub).to.have.been.calledWithMatch({
                    requestID: mockRequestId,
                    currentUser: {
                        username: mockEmail,
                        roles: [mockRole],
                        claims: {},
                    },
                    typeName: mockType.name,
                    value: mockInput,
                    version: 1,
                    context: {
                        request: {
                            headers: {
                                authorization: 'Bearer 123',
                            },
                            body: {
                                query: 'Test query',
                            },
                        },
                    },
                });
            });
            it('should return true', async () => {
                const result = await returnedFunction('', {
                    input: mockInput,
                }, mockResolverContext, mockResolverInfo);
                (0, expect_1.expect)(result).to.be.true;
            });
        });
        describe('subscriptionByIDResolverBuilder', () => {
            let mockResolverResult;
            let subscriptionResolverBuilderStub;
            let returnedFunction;
            beforeEach(() => {
                mockResolverResult = faker_1.random.alphaNumeric(10);
                subscriptionResolverBuilderStub = (0, sinon_1.stub)().returns(() => {
                    return mockResolverResult;
                });
                (0, sinon_1.replace)(graphql_generator_1.GraphQLGenerator, 'subscriptionResolverBuilder', subscriptionResolverBuilderStub);
                returnedFunction = graphql_generator_1.GraphQLGenerator.subscriptionByIDResolverBuilder(mockConfig, mockType);
            });
            it('should call subscriptionResolverBuilder', async () => {
                await returnedFunction('', {}, mockResolverContext, mockResolverInfo);
                (0, expect_1.expect)(subscriptionResolverBuilderStub).to.have.been.calledOnce;
            });
            it('should return expected result', async () => {
                const result = await returnedFunction('', {}, mockResolverContext, mockResolverInfo);
                (0, expect_1.expect)(result).to.be.equal(mockResolverResult);
            });
        });
        describe('subscriptionResolverBuilder', () => {
            let mockContextConnectionID;
            let subscribeStub;
            let returnedFunction;
            beforeEach(() => {
                mockContextConnectionID = faker_1.random.uuid();
                mockResolverContext.connectionID = mockContextConnectionID;
                subscribeStub = (0, sinon_1.stub)().resolves();
                (0, sinon_1.replace)(booster_read_models_reader_1.BoosterReadModelsReader.prototype, 'subscribe', subscribeStub);
                returnedFunction = graphql_generator_1.GraphQLGenerator.subscriptionResolverBuilder(mockConfig, mockType);
            });
            context('missing context.connectionID', () => {
                it('should throw an error', async () => {
                    mockResolverContext.connectionID = undefined;
                    let error = new Error();
                    try {
                        await returnedFunction('', {}, mockResolverContext, mockResolverInfo);
                    }
                    catch (e) {
                        error = e;
                    }
                    finally {
                        (0, expect_1.expect)(error.message).to.be.equal('Missing "connectionID". It is required for subscriptions');
                    }
                });
            });
            context('storeSubscriptions', () => {
                describe('should storeSubscriptions', () => {
                    it('should call readModelsDispatcher.subscribe', async () => {
                        mockResolverContext.storeSubscriptions = true;
                        await returnedFunction('', {}, mockResolverContext, mockResolverInfo);
                        (0, expect_1.expect)(subscribeStub).to.be.calledOnce;
                    });
                });
                describe('should not storeSubscriptions', () => {
                    it('should not call readModelsDispatcher.subscribe', async () => {
                        mockResolverContext.storeSubscriptions = false;
                        await returnedFunction('', {}, mockResolverContext, mockResolverInfo);
                        (0, expect_1.expect)(subscribeStub).to.not.be.called;
                    });
                });
            });
            it('should call pubsub.asyncIterator', async () => {
                await returnedFunction('', {}, mockResolverContext, mockResolverInfo);
                (0, expect_1.expect)(asyncIteratorStub).to.be.calledOnceWithExactly({
                    currentUser: {
                        username: mockEmail,
                        roles: [mockRole],
                        claims: {},
                    },
                    filters: {},
                    sortBy: {},
                    requestID: mockRequestId,
                    class: mockType,
                    className: mockType.name,
                    limit: undefined,
                    afterCursor: undefined,
                    paginatedVersion: false,
                    version: 1,
                    select: undefined,
                });
            });
            it('should return expected result', async () => {
                const result = await returnedFunction('', {}, mockResolverContext, mockResolverInfo);
                (0, expect_1.expect)(result).to.be.equal(mockAsyncIteratorResult);
            });
        });
        describe('eventResolver', () => {
            let fetchEventsStub;
            const fetchEventsResult = [];
            const parameters = {
                entity: 'TestEntity',
            };
            beforeEach(() => {
                fetchEventsStub = (0, sinon_1.stub)().resolves(fetchEventsResult);
                (0, sinon_1.replace)(booster_events_reader_1.BoosterEventsReader.prototype, 'fetch', fetchEventsStub);
            });
            it('should call fetch with expected payload', async () => {
                const expectedFetchEventsPayload = {
                    currentUser: {
                        username: mockEmail,
                        roles: [mockRole],
                        claims: {},
                    },
                    parameters,
                    requestID: mockRequestId,
                };
                await graphql_generator_1.GraphQLGenerator.eventResolver('', parameters, mockResolverContext);
                (0, expect_1.expect)(fetchEventsStub).to.have.been.calledOnceWithExactly(expectedFetchEventsPayload);
            });
            it('should return expected result', async () => {
                const result = await graphql_generator_1.GraphQLGenerator.eventResolver('', parameters, mockResolverContext);
                (0, expect_1.expect)(result).to.be.deep.equal(fetchEventsResult);
            });
        });
    });
});
