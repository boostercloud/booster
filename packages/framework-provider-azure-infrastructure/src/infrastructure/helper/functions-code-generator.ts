/**
 * Azure Functions v4 Programming Model Code Generator
 *
 * Generates TypeScript code for function registration using the v4 programming model.
 * Instead of generating function.json files, we generate code that uses app.*() registration.
 */
import { BoosterConfig, ScheduleInterface } from '@boostercloud/framework-types'
import { getLogger } from '@boostercloud/framework-common-helpers'

export class FunctionsCodeGenerator {
  constructor(readonly config: BoosterConfig) {}

  /**
   * Generates the complete functions.ts file content for Azure Functions v4
   */
  public generateFunctionsCode(): string {
    const logger = getLogger(this.config, 'FunctionsCodeGenerator#generateFunctionsCode')
    logger.info('Generating Azure Functions v4 registration code')

    const imports = this.generateImports()
    const functions: string[] = []

    // Always include GraphQL and Health endpoints
    functions.push(this.generateGraphQLFunction())
    functions.push(this.generateHealthFunction())

    // Event handling (either Cosmos DB or Event Hub based)
    if (this.config.eventStreamConfiguration.enabled) {
      functions.push(this.generateEventStreamProducerFunction())
    } else {
      functions.push(this.generateEventHandlerFunction())
    }

    // WebSocket/Subscriptions functions
    if (this.config.enableSubscriptions) {
      functions.push(this.generateWebPubSubConnectFunction())
      functions.push(this.generateWebPubSubDisconnectFunction())
      functions.push(this.generateWebPubSubMessagesFunction())
      functions.push(...this.generateSubscriptionsNotifierFunctions())
    }

    // Scheduled command functions
    functions.push(...this.generateScheduledFunctions())

    logger.info('Azure Functions v4 registration code generated')
    return [imports, '', ...functions].join('\n')
  }

  /**
   * Generates the complete functions.ts file content for consumer functions
   */
  public generateConsumerFunctionsCode(): string {
    if (!this.config.eventStreamConfiguration.enabled) {
      return ''
    }

    const logger = getLogger(this.config, 'FunctionsCodeGenerator#generateConsumerFunctionsCode')
    logger.info('Generating Azure Consumer Functions v4 registration code')

    const imports = this.generateImports()
    const functions: string[] = []

    functions.push(this.generateEventStreamConsumerFunction())

    logger.info('Azure Consumer Functions v4 registration code generated')
    return [imports, '', ...functions].join('\n')
  }

  private generateImports(): string {
    return `/**
 * Azure Functions v4 Registration
 * Auto-generated by Booster Framework - DO NOT EDIT
 */
const { app, trigger } = require('@azure/functions')
const {
  boosterEventDispatcher,
  boosterServeGraphQL,
  boosterTriggerScheduledCommands,
  boosterNotifySubscribers,
  boosterConsumeEventStream,
  boosterProduceEventStream,
  boosterHealth,
} = require('./dist/index')
`
  }

  private generateGraphQLFunction(): string {
    return `
// GraphQL HTTP endpoint
app.http('graphql', {
  methods: ['POST'],
  authLevel: 'anonymous',
  handler: async (request, context) => {
    const input = { request, context }
    return await boosterServeGraphQL(input)
  }
})
`
  }

  private generateHealthFunction(): string {
    return `
// Health check HTTP endpoint
app.http('sensor-health', {
  methods: ['GET'],
  authLevel: 'anonymous',
  route: 'sensor/health/{*componentPath}',
  handler: async (request, context) => {
    const input = { request, context }
    return await boosterHealth(input)
  }
})
`
  }

  private generateEventHandlerFunction(): string {
    const databaseName = this.config.resourceNames.applicationStack
    const containerName = this.config.resourceNames.eventsStore

    return `
// Cosmos DB event handler (processes events from the events store)
app.cosmosDB('eventHandler', {
  connection: 'COSMOSDB_CONNECTION_STRING',
  databaseName: '${databaseName}',
  containerName: '${containerName}',
  createLeaseContainerIfNotExists: true,
  leaseContainerName: 'leases',
  handler: async (documents, context) => {
    const input = { documents, context }
    await boosterEventDispatcher(input)
  }
})
`
  }

  private generateEventStreamProducerFunction(): string {
    const databaseName = this.config.resourceNames.applicationStack
    const containerName = this.config.resourceNames.eventsStore

    return `
// Cosmos DB event stream producer (sends events to Event Hub)
app.cosmosDB('eventProducer', {
  connection: 'COSMOSDB_CONNECTION_STRING',
  databaseName: '${databaseName}',
  containerName: '${containerName}',
  createLeaseContainerIfNotExists: true,
  leaseContainerName: 'leases',
  handler: async (documents, context) => {
    const input = { documents, context }
    await boosterProduceEventStream(input)
  }
})
`
  }

  private generateEventStreamConsumerFunction(): string {
    const eventHubName = this.config.resourceNames.streamTopic || 'events-stream'

    return `
// Event Hub consumer (processes events from the event stream)
app.eventHub('eventConsumer', {
  connection: 'EVENTHUB_CONNECTION_STRING',
  eventHubName: '${eventHubName}',
  cardinality: 'many',
  handler: async (messages, context) => {
    const input = { messages, context }
    await boosterConsumeEventStream(input)
  }
})
`
  }

  private generateWebPubSubConnectFunction(): string {
    return `
// Web PubSub connect handler
const connectTrigger = trigger.generic({
  type: 'webPubSubTrigger',
  name: 'request',
  hub: 'booster',
  eventType: 'system',
  eventName: 'connect',
  connection: 'WebPubSubConnectionString'
})

app.generic('connect', {
  trigger: connectTrigger,
  handler: async (request, context) => {
    try {
      context.log('WebPubSub CONNECT - request:', JSON.stringify(request, null, 2))
      context.log('WebPubSub CONNECT - triggerMetadata:', JSON.stringify(context.triggerMetadata, null, 2))
      const input = { request, context }
      const result = await boosterServeGraphQL(input)
      context.log('WebPubSub CONNECT - result:', JSON.stringify(result, null, 2))
      return result
    } catch (error) {
      context.error('WebPubSub CONNECT error:', error)
      // Return error response for connect event
      return { code: 'InternalError', errorMessage: error.message || 'Internal server error' }
    }
  }
})
`
  }

  private generateWebPubSubDisconnectFunction(): string {
    return `
// Web PubSub disconnect handler
const disconnectTrigger = trigger.generic({
  type: 'webPubSubTrigger',
  name: 'request',
  hub: 'booster',
  eventType: 'system',
  eventName: 'disconnect',
  connection: 'WebPubSubConnectionString'
})

app.generic('disconnect', {
  trigger: disconnectTrigger,
  handler: async (request, context) => {
    try {
      const input = { request, context }
      return await boosterServeGraphQL(input)
    } catch (error) {
      context.error('WebPubSub DISCONNECT error:', error)
      return undefined
    }
  }
})
`
  }

  private generateWebPubSubMessagesFunction(): string {
    return `
// Web PubSub messages handler
const messagesTrigger = trigger.generic({
  type: 'webPubSubTrigger',
  name: 'request',
  hub: 'booster',
  eventType: 'user',
  eventName: 'message',
  connection: 'WebPubSubConnectionString'
})

app.generic('messages', {
  trigger: messagesTrigger,
  handler: async (request, context) => {
    try {
      const input = { request, context }
      return await boosterServeGraphQL(input)
    } catch (error) {
      context.error('WebPubSub MESSAGE error:', error)
      return { data: { errors: [{ message: error.message || 'Internal server error' }] }, dataType: 'json' }
    }
  }
})
`
  }

  private generateSubscriptionsNotifierFunctions(): string[] {
    const functions: string[] = []
    const databaseName = this.config.resourceNames.applicationStack

    // Generate a notifier function for each read model
    for (const readModelName of Object.keys(this.config.readModels)) {
      const containerName = this.config.resourceNames.forReadModel(readModelName)
      const functionName = `${readModelName}-subscriptions-notifier`

      functions.push(`
// Subscriptions notifier for ${readModelName}
app.cosmosDB('${functionName}', {
  connection: 'COSMOSDB_CONNECTION_STRING',
  databaseName: '${databaseName}',
  containerName: '${containerName}',
  createLeaseContainerIfNotExists: true,
  leaseContainerName: 'leases',
  handler: async (documents, context) => {
    const input = { documents, context, typeName: '${readModelName}' }
    await boosterNotifySubscribers(input)
  }
})
`)
    }

    return functions
  }

  private generateScheduledFunctions(): string[] {
    const functions: string[] = []

    if (!this.config.scheduledCommandHandlers || Object.keys(this.config.scheduledCommandHandlers).length === 0) {
      return functions
    }

    for (const [commandName, metadata] of Object.entries(this.config.scheduledCommandHandlers)) {
      if (!metadata.scheduledOn || Object.keys(metadata.scheduledOn).length === 0) {
        continue
      }

      const cronExpression = this.createCronExpression(metadata.scheduledOn)
      const functionName = `scheduleFunction-${commandName}`

      functions.push(`
// Scheduled command: ${commandName}
app.timer('${functionName}', {
  schedule: '${cronExpression}',
  handler: async (timer, context) => {
    const input = { timer, context, typeName: '${commandName}' }
    await boosterTriggerScheduledCommands(input)
  }
})
`)
    }

    return functions
  }

  /**
   * Azure Functions uses the NCronTab library to interpret NCRONTAB expressions.
   * An NCRONTAB expression includes an additional sixth field at the beginning for seconds:
   * {second} {minute} {hour} {day} {month} {day-of-week}
   */
  private createCronExpression(schedule: ScheduleInterface): string {
    const { minute = '*', hour = '*', day = '*', month = '*', weekDay = '*' } = schedule
    return `0 ${minute} ${hour} ${day} ${month} ${weekDay}`
  }
}
