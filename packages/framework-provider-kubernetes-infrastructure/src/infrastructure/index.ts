import { BoosterConfig, Logger } from '@boostercloud/framework-types'
import { K8sManagement } from './k8s-sdk/k8s-management'
import { HelmManager } from './helm-manager'
import { DeployManager } from './deploy-manager'
import { DaprManager } from './dapr-manager'
import { Promises } from '@boostercloud/framework-common-helpers'
export interface BoosterK8sConfiguration extends BoosterConfig {
  context?: string
}

export const deploy = (configuration: BoosterConfig, logger: Logger): Promise<void> =>
  deployBoosterApp(logger, configuration)

export const nuke = (configuration: BoosterConfig, logger: Logger): Promise<void> =>
  nukeBoosterApp(logger, configuration)

async function deployBoosterApp(logger: Logger, configuration: BoosterK8sConfiguration): Promise<void> {
  const clusterManager = new K8sManagement(logger)
  const helmManager = new HelmManager(logger)
  const daprManager = new DaprManager(logger, configuration, clusterManager, helmManager)
  const deployManager = new DeployManager(logger, configuration, clusterManager, daprManager, helmManager)
  if (configuration.context) {
    logger.info(`Setting Kubectl context to ${configuration.context}`)
    await clusterManager.setClusterContext(configuration.context)
  }
  logger.info('Checking your cluster and installed tools')
  await Promises.allSettledAndFulfilled([deployManager.ensureNamespaceExists(), deployManager.ensureHelmIsReady()])
  logger.info('Checking your volume claim')
  await deployManager.ensureVolumeClaimExists()
  logger.info('Deploying all necessary services')
  await deployManager.setServiceType()
  await Promises.allSettledAndFulfilled([
    deployManager.ensureUploadServiceExists(),
    deployManager.ensureBoosterServiceExists(),
  ])
  logger.info('Checking your Dapr services and event store')
  await deployManager.ensureDaprExists()
  await deployManager.ensureEventStoreExists()
  await daprManager.registerEventStoreInDapr()
  logger.info('Waiting for cluster to be ready to receive your code')
  await deployManager.ensureUploadPodExists()
  logger.info('Packing and uploading your code into the cluster')
  await deployManager.uploadUserCode()
  logger.info('Deploying your booster app ðŸš€')
  const serviceURL = await deployManager.deployBoosterApp(
    daprManager.eventStoreHost,
    daprManager.eventStoreUser,
    daprManager.eventStoreSecretName,
    daprManager.eventStoreSecretKey
  )
  logger.info(`Your app is ready in this url: http://${serviceURL}/graphql`)
}

async function nukeBoosterApp(logger: Logger, configuration: BoosterK8sConfiguration): Promise<void> {
  const clusterManager = new K8sManagement(logger)
  const helmManager = new HelmManager(logger)
  const daprManager = new DaprManager(logger, configuration, clusterManager, helmManager)
  const deployManager = new DeployManager(logger, configuration, clusterManager, daprManager, helmManager)
  if (configuration.context) {
    logger.info(`Setting Kubectl context to ${configuration.context}`)
    await clusterManager.setClusterContext(configuration.context)
  }
  logger.info('Nuking your Booster project ðŸ§¨')
  await deployManager.deleteDapr()
  logger.info('Nuking your event store if it was generated by Booster')
  await deployManager.deleteRedis()
  logger.info('Finishing to delete all resources')
  await deployManager.deleteAllResources()
  logger.info('Your app is terminated and destroyed ðŸ’¥')
}
