"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/0000-index","metadata":{"permalink":"/blog/0000-index","editUrl":"https://github.com/boostercloud/booster/edit/main/website/proposals/0000-index/index.mdx","source":"@site/proposals/0000-index/index.mdx","title":"BEEP 0 - Index of Booster Evolution Enhancement Proposals","description":"This BEEP will contain the index of all Booster Evolution Enhancement Proposals, known as BEEPs. BEEP numbers are assigned by the BEEP editors, and once assigned are never changed.","date":"2024-01-24T00:00:00.000Z","formattedDate":"January 24, 2024","tags":[],"readingTime":0.33,"hasTruncateMarker":false,"authors":[{"name":"Nick Tchayka","title":"Booster Core Team","url":"https://github.com/NickSeagull","imageURL":"https://github.com/NickSeagull.png","key":"NickSeagull"}],"frontMatter":{"title":"BEEP 0 - Index of Booster Evolution Enhancement Proposals","authors":["NickSeagull"],"date":"2024-01-24T00:00"},"unlisted":false,"nextItem":{"title":"BEEP 1 - Purpose and Guidelines","permalink":"/blog/0001-purpose-and-guidelines"}},"content":":::caution STATUS - DRAFT\\n:::\\n\\nThis BEEP will contain the index of all **Booster Evolution Enhancement Proposals**, known as BEEPs. BEEP numbers are assigned by the BEEP editors, and once assigned are never changed.\\n\\nIn the future, the BEEPs will be listed here by category. For now, use the sidebar on the left.\\n\\nA good starting point is [BEEP 1](./0001-purpose-and-guidelines), which describes the BEEP process itself."},{"id":"/0001-purpose-and-guidelines","metadata":{"permalink":"/blog/0001-purpose-and-guidelines","editUrl":"https://github.com/boostercloud/booster/edit/main/website/proposals/0001-purpose-and-guidelines/index.mdx","source":"@site/proposals/0001-purpose-and-guidelines/index.mdx","title":"BEEP 1 - Purpose and Guidelines","description":"What is a BEEP?","date":"2024-01-24T00:01:00.000Z","formattedDate":"January 24, 2024","tags":[],"readingTime":1.99,"hasTruncateMarker":false,"authors":[{"name":"Nick Tchayka","title":"Booster Core Team","url":"https://github.com/NickSeagull","imageURL":"https://github.com/NickSeagull.png","key":"NickSeagull"}],"frontMatter":{"title":"BEEP 1 - Purpose and Guidelines","authors":["NickSeagull"],"date":"2024-01-24T00:01"},"unlisted":false,"prevItem":{"title":"BEEP 0 - Index of Booster Evolution Enhancement Proposals","permalink":"/blog/0000-index"},"nextItem":{"title":"BEEP 2 - Target and User Persona","permalink":"/blog/0002-project-target"}},"content":":::info STATUS - IN PROGRESS\\n:::\\n\\n## What is a BEEP?\\n\\nBEEP stands for Booster Evolution Enhancement Proposal. It is a document that describes a change or addition to Booster.\\n\\n## Statuses of a BEEP\\n\\nA BEEP can have one of the following statuses:\\n\\n:::caution STATUS - DRAFT\\nThis status indicates that the BEEP is still being written and is not ready for review.\\n:::\\n\\n:::info STATUS - IN PROGRESS\\nThis status indicates that the BEEP has been accepted but is still being implemented.\\n:::\\n\\n:::tip STATUS - INTEGRATED\\nThis status indicates that the BEEP has been implemented.\\n:::\\n\\n:::tip STATUS - ACCEPTED\\nThis status is for informational BEEPs that have been accepted.\\n:::\\n\\n:::danger STATUS - REJECTED\\nThis status indicates that the BEEP has been rejected.\\n:::\\n\\n## How to contribute to the design process\\n\\nEveryone is welcome to propose, discuss, and review ideas to improve Booster in the `#proposals` channel of the Discord server.\\n\\nNote that the project is in a very early stage, and the contribution to the design process is not well defined.\\n\\nAs some general rules for now, take this into account before submitting a proposal:\\n\\n- No \\"What about if Booster does a 180-degree turn and instead does this completely unrelated thing?\\". These kinds of proposals are **seen as completely out of the scope of the Booster project and will be instantly dismissed.**\\n- **Use constructive criticism.** Instead of \\"remove this, I don\'t like it\\", take a moment to think and give actual reasons like \\"I believe that this function in the standard library is not clear enough, someone could understand this in a wrong way\\"\\n- Is the problem being addressed **impactful enough** to warrant a change to Booster?\\n- How does this impact the [**Principle of Least Astonishment**](https://en.wikipedia.org/wiki/Principle_of_least_astonishment) of the project?\\n- How does this impact the [**Principle of Developer Happiness**](https://www.forbes.com/sites/forbestechcouncil/2023/09/22/ensuring-developer-happiness-how-to-hang-on-to-software-engineers) of the project?\\n- How does this impact the [**Principle of Least Effort**](https://simplicable.com/design/principle-of-least-effort) of the project? Both externally for the users and internally for the maintainers.\\n- Does this proposal fit well with the **feel and direction** of Booster?\\n- What **other libraries/languages** got you inspired to submit this proposal? How does this compare to those?\\n- How much **effort** did you put into your review? A glance, a quick reading, or an in-depth study?\\n\\nPlease **state explicitly** whether you believe that the proposal should be accepted into Booster."},{"id":"/0002-project-target","metadata":{"permalink":"/blog/0002-project-target","editUrl":"https://github.com/boostercloud/booster/edit/main/website/proposals/0002-project-target/index.mdx","source":"@site/proposals/0002-project-target/index.mdx","title":"BEEP 2 - Target and User Persona","description":"Introduction","date":"2024-01-25T00:00:00.000Z","formattedDate":"January 25, 2024","tags":[],"readingTime":2.695,"hasTruncateMarker":false,"authors":[{"name":"Nick Tchayka","title":"Booster Core Team","url":"https://github.com/NickSeagull","imageURL":"https://github.com/NickSeagull.png","key":"NickSeagull"}],"frontMatter":{"title":"BEEP 2 - Target and User Persona","authors":["NickSeagull"],"date":"2024-01-25T00:00"},"unlisted":false,"prevItem":{"title":"BEEP 1 - Purpose and Guidelines","permalink":"/blog/0001-purpose-and-guidelines"},"nextItem":{"title":"BEEP 3 - Principles of Design","permalink":"/blog/0003-principles-of-design"}},"content":":::tip STATUS - ACCEPTED\\n:::\\n\\n## Introduction\\n\\nThis document defines the target audience and [user persona](<https://en.wikipedia.org/wiki/Persona_(user_experience)>) for the Booster Framework project, aligning it with its current usage and user base.\\n\\nWhile maintaining a focus on guiding the design and development process of the Booster Framework, this definition is not an exclusionary rule but a strategic tool for decision-making. The framework is inclusive and welcomes a diverse range of users, though particular emphasis is placed on specific user groups in design and functionality.\\n\\n## Target Audience\\n\\nThe primary target audience for the Booster Framework is developers in large-scale enterprise environments, familiar with enterprise technologies like Java, .NET, or similar. This includes those working in Fortune 500 companies, especially those transitioning from traditional enterprise technologies to TypeScript in complex projects such as financial transactions.\\n\\nAdditionally, the Booster Framework is gaining traction among hobbyist developers for personal projects, thanks to its ease of use and efficient learning curve. This secondary audience appreciates the framework for its quick setup, minimal configuration, and straightforward deployment, which are ideal for smaller-scale, personal projects.\\n\\n### Who\'s not the target audience\\n\\n- Developers deeply invested in exploring advanced theoretical concepts in programming without practical application.\\n- Those who prefer frameworks with a steep learning curve or require extensive configuration.\\n\\n## User Persona\\n\\n### Primary Persona: Enterprise Developer\\n- **Name**: Aarya\\n- **Role**: Senior Enterprise Software Developer\\n\\n#### Actions, Motivations, and Pains\\n\\n- **What do I do?**\\n  - Work on large-scale TypeScript projects, transitioning from a background in traditional enterprise technologies.\\n  - Develop robust applications for sectors like finance, requiring high security and reliability.\\n- **Why do I do it?**\\n  - To apply my experience in enterprise technologies in new, dynamic environments.\\n  - To contribute significantly to business-critical projects.\\n- **What do I want?**\\n  - A framework that bridges my existing knowledge with modern development practices.\\n  - Tools that ensure efficiency, security, and compatibility with enterprise standards.\\n- **What\'s stopping me?**\\n  - Adapting to new technologies while maintaining high standards of enterprise development.\\n  - Balancing rapid development with regulatory and security requirements.\\n\\n### Secondary Persona: Hobbyist Developer\\n- **Name**: Navin\\n- **Role**: Hobbyist Developer\\n\\n#### Actions, Motivations, and Pains\\n\\n- **What do I do?**\\n  - Develop personal projects in my spare time, exploring new technologies and ideas.\\n  - Seek tools that enable quick and easy project setup and deployment.\\n- **Why do I do it?**\\n  - To learn new skills and stay updated with the latest technology trends.\\n  - To bring personal project ideas to life efficiently.\\n- **What do I want?**\\n  - A user-friendly framework that doesn\'t require extensive setup or configuration.\\n  - Resources that help me quickly understand and apply the framework.\\n- **What\'s stopping me?**\\n  - Overly complex tools that require significant time investment to learn.\\n  - Lack of clear, beginner-friendly documentation and community support.\\n\\n## Conclusion\\n\\nThis document outlines the dual focus of the Booster Framework\'s target audience and user personas. Our development and design efforts are directed towards supporting both the enterprise developers transitioning from traditional technologies to TypeScript, and the growing community of hobbyist developers seeking an accessible and easy-to-use framework for personal projects. This approach ensures the Booster Framework remains versatile and relevant across different scales and scopes of software development."},{"id":"/0003-principles-of-design","metadata":{"permalink":"/blog/0003-principles-of-design","editUrl":"https://github.com/boostercloud/booster/edit/main/website/proposals/0003-principles-of-design/index.mdx","source":"@site/proposals/0003-principles-of-design/index.mdx","title":"BEEP 3 - Principles of Design","description":"Introduction","date":"2024-01-25T00:01:00.000Z","formattedDate":"January 25, 2024","tags":[],"readingTime":3.715,"hasTruncateMarker":false,"authors":[{"name":"Nick Tchayka","title":"Booster Core Team","url":"https://github.com/NickSeagull","imageURL":"https://github.com/NickSeagull.png","key":"NickSeagull"}],"frontMatter":{"title":"BEEP 3 - Principles of Design","authors":["NickSeagull"],"date":"2024-01-25T00:01"},"unlisted":false,"prevItem":{"title":"BEEP 2 - Target and User Persona","permalink":"/blog/0002-project-target"},"nextItem":{"title":"BEEP 4 - Semantic Versioning","permalink":"/blog/0004-semantic-versioning"}},"content":":::tip STATUS - ACCEPTED\\n:::\\n\\n## Introduction\\n\\nThis document lays out the design principles guiding the design and implementation processes of the Booster Framework. These principles are crucial in steering both high-level and low-level decision-making within the project. They are pivotal in ensuring that the project remains focused on the correct aspects of design and implementation, always keeping in mind [the target audience and user persona](/blog/0002-project-target), as they are the most important stakeholders of the project.\\n\\n## Principle of Least Astonishment\\n\\nThe Principle of Least Astonishment, also known as the Principle of Least Surprise, is a fundamental guideline in user interface and software design. It stresses the importance of creating systems that behave in ways consistent with user expectations, minimizing surprise and confusion. This principle is crucial in the Booster Framework, ensuring that the framework\'s components and functionalities align with the conventions familiar to both enterprise and hobbyist developers, thereby enhancing their experience and usability. It is particularly relevant in a context where developers are transitioning from traditional enterprise technologies to modern TypeScript-based environments, as it aids in reducing the learning curve and preventing user astonishment.\\n\\n### Examples\\n\\n- Favoring JSON or YAML for configuration over more complex formats, aligning with common industry practices.\\n- Integrating with popular version control systems like Git and widely-used platforms such as GitHub or GitLab.\\n- Recommending mainstream IDEs like Visual Studio Code, which are familiar to a broad range of developers.\\n- Ensuring that the framework\'s functionalities and syntax are intuitive and align with common programming practices.\\n\\n## Principle of Developer Happiness\\n\\nThe Principle of Developer Happiness is centered around creating an environment and culture that aligns with developers\' professional and personal expectations, thereby enhancing satisfaction and retention. This principle is key in the Booster Framework, focusing on an engaging experience and a supportive culture where developers, regardless of their background, feel valued and connected to the project\'s mission. It also involves using efficient tools and technologies to streamline the development process and saving time, along with continuously assessing developer efficiency and satisfaction.\\n\\n### Examples\\n\\n- **Comprehensive Documentation**: Providing clear and user-friendly documentation with practical examples for both enterprise and hobbyist developers.\\n- **Active Community Engagement**: Encouraging participation and collaboration within the open-source community.\\n- **Transparent Decision-Making**: Keeping language development and framework enhancement decisions transparent.\\n- **Inclusive Onboarding**: Offering learning resources and support for developers of varying skill levels.\\n- **Acknowledgement of Contributions**: Recognizing and valuing contributions from the community, regardless of their scale.\\n- **Open Feedback Channels**: Maintaining open channels for feedback, suggestions, and issue reporting from users and contributors.\\n\\n## Principle of Least Effort\\n\\nThe Principle of Least Effort emphasizes the idea that entities will naturally gravitate towards the solution that requires the least amount of work or complexity. In the context of the Booster Framework, this principle is applied to create systems and interfaces that are straightforward, easy to comprehend, and simple to interact with. This reduces the cognitive and operational load on users, particularly those transitioning from different technology backgrounds. For developers, it encourages the creation of code and architectures that are clean, efficient, and easy to understand and modify. By adhering to this principle, the Booster Framework aims to offer user-friendly applications and sustainably maintainable codebases, promoting efficient interactions for all users.\\n\\n### Examples\\n\\n- **Intuitive Syntax and Features**: Designing the framework with a simple, intuitive syntax that reduces cognitive load, particularly for those new to TypeScript.\\n- **Streamlined Documentation**: Providing clear, concise documentation that helps users quickly understand and utilize the framework.\\n- **Robust Standard Libraries**: Including comprehensive standard libraries that simplify common development tasks.\\n- **Effective Error Handling**: Implementing user-friendly error messages and handling mechanisms for efficient problem-solving.\\n- **Strong Community Support**: Building a supportive community for knowledge sharing and collaboration, reducing the effort needed to overcome challenges.\\n- **Simplified Version Management**: Facilitating easy version management and updates for seamless adoption of new features and improvements.\\n\\n## Conclusion\\n\\nThe design principles outlined for the Booster Framework serve as a guiding light for the project\'s development and implementation processes. The Principle of Least Astonishment ensures system behavior aligns with user expectations, enhancing usability. The Principle of Developer Happiness focuses on creating a fulfilling environment for developers, while the Principle of Least Effort promotes simplicity and efficiency. These principles collectively ensure that the Booster Framework remains attuned to the needs of its diverse user base, from enterprise developers to hobbyist programmers, ensuring a user-centric, efficient, and developer-friendly journey throughout its development."},{"id":"/0004-semantic-versioning","metadata":{"permalink":"/blog/0004-semantic-versioning","editUrl":"https://github.com/boostercloud/booster/edit/main/website/proposals/0004-semantic-versioning/index.mdx","source":"@site/proposals/0004-semantic-versioning/index.mdx","title":"BEEP 4 - Semantic Versioning","description":"Introduction","date":"2024-01-25T00:03:00.000Z","formattedDate":"January 25, 2024","tags":[],"readingTime":2.305,"hasTruncateMarker":false,"authors":[{"name":"Nick Tchayka","title":"Booster Core Team","url":"https://github.com/NickSeagull","imageURL":"https://github.com/NickSeagull.png","key":"NickSeagull"}],"frontMatter":{"title":"BEEP 4 - Semantic Versioning","authors":["NickSeagull"],"date":"2024-01-25T00:03"},"unlisted":false,"prevItem":{"title":"BEEP 3 - Principles of Design","permalink":"/blog/0003-principles-of-design"},"nextItem":{"title":"BEEP 5 - Agent-Based Codebase Structure","permalink":"/blog/0005-agent-codebase"}},"content":":::tip STATUS - ACCEPTED\\n:::\\n\\n## Introduction\\n\\nIn the context of the Booster Framework ecosystem, we adopt the [Semantic Versioning](https://semver.org/) (SemVer) schema. SemVer is a system of rules and guidelines for assigning and incrementing version numbers within our software development process. By using SemVer, the Booster Framework aims to manage the complexities of dependencies as the ecosystem evolves. The primary goal of implementing Semantic Versioning is to ensure that our version numbers are transparent and informative, effectively communicating the nature of changes in our software to both enterprise and hobbyist developers.\\n\\n## Impact on Principle of Least Astonishment\\n\\nSemantic Versioning positively impacts the Principle of Least Astonishment. It is a widely recognized and used schema in numerous open-source projects. Adhering to a clear and consistent version numbering system (Major.Minor.Patch) reduces confusion and surprise for developers and users alike. This predictability in versioning enhances the user experience and facilitates the management of software dependencies.\\n\\n## Impact on Principle of Developer Happiness\\n\\nSemantic Versioning aligns with the Principle of Developer Happiness by offering a systematic and standardized approach to versioning. This method simplifies the process of releasing and updating software packages, allowing developers to confidently implement changes. Knowing that version numbers accurately reflect the impact of changes reduces the stress related to dependency management and enables developers to concentrate on innovation and software improvement.\\n\\n## Impact on Principle of Least Effort\\n\\nSemantic Versioning supports the Principle of Least Effort by making the management of software dependencies more straightforward. By adhering to SemVer, developers can introduce backward-compatible changes without needing new major releases, thereby minimizing the effort needed for maintaining and updating software. Additionally, the clear documentation of public APIs and the use of version numbers to indicate compatibility simplify the integration of dependencies, reducing the effort needed for seamless software interactions.\\n\\n## Usage of SemVer in Early Development Phases\\n\\nDuring the initial development phases of Booster Framework projects, the major version will remain at 0. This indicates that breaking changes are likely to be frequent as the project evolves. Once the project achieves a stable state, the major version will be incremented to 1, signifying a reduction in the frequency of breaking changes.\\n\\n## Standardizing the Use of SemVer\\n\\nWe advise using the Semantic Versioning schema as a standard across all Booster Framework projects. This uniformity will ensure coherence within the ecosystem. The Booster CLI tool should facilitate version management by inspecting exported functions and types, suggesting the next version based on the changes made.\\n\\n## Considerations\\n\\nIt\'s important to note that changes in the implementation of a function, even without altering the API, can produce different results and are considered breaking changes. These should be reflected in the version number accordingly. For more information and examples, please refer to this [GitHub thread](https://github.com/semver/semver/issues/311)."},{"id":"/0005-agent-codebase","metadata":{"permalink":"/blog/0005-agent-codebase","editUrl":"https://github.com/boostercloud/booster/edit/main/website/proposals/0005-agent-codebase/index.mdx","source":"@site/proposals/0005-agent-codebase/index.mdx","title":"BEEP 5 - Agent-Based Codebase Structure","description":"Introduction","date":"2024-01-25T00:04:00.000Z","formattedDate":"January 25, 2024","tags":[],"readingTime":3.65,"hasTruncateMarker":false,"authors":[{"name":"Nick Tchayka","title":"Booster Core Team","url":"https://github.com/NickSeagull","imageURL":"https://github.com/NickSeagull.png","key":"NickSeagull"}],"frontMatter":{"title":"BEEP 5 - Agent-Based Codebase Structure","authors":["NickSeagull"],"date":"2024-01-25T00:04"},"unlisted":false,"prevItem":{"title":"BEEP 4 - Semantic Versioning","permalink":"/blog/0004-semantic-versioning"},"nextItem":{"title":"BEEP 6 - Remote Imports","permalink":"/blog/0006-remote-imports"}},"content":":::tip STATUS - DRAFT\\n:::\\n\\n## Introduction\\n\\nThis document proposes a significant reorganization of the Booster Framework\'s folder structure to address current challenges in codebase management and to align with the principles of modularity and scalability. The current structure, `src/{commands,events,entities,read-models}/*.ts`, while functional, has shown limitations in managing complexity as the framework and the team grow.\\n\\nThis proposal introduces a new structure based on the concept of \\"Agents\\" in event sourcing/event-driven systems, aiming to bring conceptual clarity and improved organization to the codebase. It can be thought as **the microservices approach, but more tailored to the event-driven** nature of Booster Framework.\\n\\n## Current Challenges\\n\\nThe existing folder structure in the Booster Framework presents several challenges:\\n\\n- **Lack of Modularity**: The mixed nature of components (commands, events, entities, read-models) in a flat structure leads to difficulties in isolating specific functionalities or use cases.\\n- **Scalability Concerns**: As the team and the codebase grow, the lack of hierarchical organization makes it increasingly challenging to manage and navigate the codebase.\\n- **Interdependency Issues**: The current structure does not clearly delineate dependencies and relationships between different components, leading to potential conflicts and complexities.\\n\\n## Proposed Folder Structure\\n\\nThe new folder structure is organized around the concept of \\"Agents\\", where each use case is encapsulated within its own subfolder. This approach mirrors the modular and event-driven nature of the Booster Framework.\\n\\n### Structure Overview\\n\\n- `src/`\\n  - `agents/`\\n    - `agent-name-1/`\\n      - `commands/`\\n      - `events/`\\n      - `entities/`\\n      - `read-models/`\\n    - `agent-name-2/`\\n      - `commands/`\\n      - `events/`\\n      - `entities/`\\n      - `read-models/`\\n    - ...\\n  - `shared/`\\n    - `common-entities/`\\n    - `utilities/`\\n    - ...\\n\\n### Guidelines for Naming Subfolders\\n\\n- **Reflective of Use Case**: Each subfolder (agent) should be named in a way that clearly reflects its specific use case or domain.\\n- **Consistent Naming Convention**: A uniform naming convention should be adopted across all agents to maintain consistency and readability.\\n\\n## Benefits of the Reorganization\\n\\n- **Improved Modularity**: Each agent acts as a self-contained module, enhancing the clarity and separation of different aspects of the codebase.\\n- **Enhanced Scalability**: This structure supports the growth of the team and the codebase, allowing for easier navigation and management.\\n- **Facilitated Collaboration**: Teams can focus on specific agents without interfering with others, simplifying collaboration and reducing the risk of conflicts.\\n- **Repository Splitting**: The modular nature of this structure allows for splitting the codebase into separate repositories if necessary for better scalability and management.\\n\\n## Addressing Potential Challenges\\n\\n### Interaction and Communication Between Agents\\n\\n- **Well-Defined Interfaces**: Clear interfaces and communication protocols between agents must be established to ensure smooth interactions.\\n- **Shared Resources Management**: The `shared/` folder will house common entities and utilities, accessible to all agents while maintaining their independence.\\n\\n### Technical and Implementation Considerations\\n\\n- **Incremental Transition**: A phased approach to migrating to the new structure is recommended to minimize disruption.\\n  - The team can start by putting everything in the `shared/` folder, then gradually move to the new structure.\\n- **Documentation and Communication**: The team should be in charge of having documentation and communication sessions in order to ensure that everyone is on the same page and responsibilities are not duplicated.\\n\\n## Additional Ideas\\n\\n### Integration of AI Agents\\n\\nIn line with the event-driven architecture of the Booster Framework, an intriguing extension to the proposed semantic codebase structure is the **incorporation of AI agents**. These agents, mirroring the structure of traditionally-programmed agents with `commands`, `events`, `read-models`, etc., would have their internal logic powered by **Large Language Models (LLMs)**.\\n\\nThis integration aligns with the scalable and modular design of the framework, allowing AI agents to **autonomously handle specific tasks or workflows within their domain**. The use of AI agents could significantly enhance the framework\'s capabilities in areas such as:\\n\\n- **Automated decision-making**\\n- **Predictive analytics**\\n- **Personalized user interactions**\\n\\nEach AI agent would operate within its designated subfolder, ensuring a **clear delineation and manageable interaction** with regular agents, while adhering to the same communication protocols and interface standards established in the overall framework.\\n\\nThis innovative approach opens new avenues for efficiency, creativity, and advanced functionalities within the Booster Framework ecosystem.\\n\\n## Conclusion\\n\\nThe proposed semantic codebase structure for Booster Framework aims to address current challenges in codebase management while aligning with the principles of modularity and scalability. This reorganization, centered around the concept of \\"Agents\\", offers numerous benefits, including improved code separation, easier collaboration, and the potential for scalable codebase management."},{"id":"/0006-remote-imports","metadata":{"permalink":"/blog/0006-remote-imports","editUrl":"https://github.com/boostercloud/booster/edit/main/website/proposals/0006-remote-imports/index.mdx","source":"@site/proposals/0006-remote-imports/index.mdx","title":"BEEP 6 - Remote Imports","description":"Introduction","date":"2024-01-26T00:00:00.000Z","formattedDate":"January 26, 2024","tags":[],"readingTime":2.92,"hasTruncateMarker":false,"authors":[{"name":"Nick Tchayka","title":"Booster Core Team","url":"https://github.com/NickSeagull","imageURL":"https://github.com/NickSeagull.png","key":"NickSeagull"}],"frontMatter":{"title":"BEEP 6 - Remote Imports","authors":["NickSeagull"],"date":"2024-01-26T00:00"},"unlisted":false,"prevItem":{"title":"BEEP 5 - Agent-Based Codebase Structure","permalink":"/blog/0005-agent-codebase"},"nextItem":{"title":"BEEP 7 - Progressive component Integration Enhancement","permalink":"/blog/0007-components"}},"content":":::tip STATUS - DRAFT\\n:::\\n\\n## Introduction\\n\\nThis document proposes a novel solution to address the challenges encountered by the team following the restructuring of Booster Framework codebase into [distinct agents](/blog/0005-agent-codebase) and separate repositories. The primary challenge involves enabling easy importation of types and classes from other agents without relying on traditional package managers. The proposed solution introduces a new endpoint, `/inspect`, in Booster services, coupled with an extension to the TypeScript compiler through a specialized plugin (transformer). This approach aims to streamline development, ensure access to up-to-date type definitions, and facilitate seamless agent interaction.\\n\\n## Context and Challenges\\n\\nAfter splitting the project codebase into individual agents and repositories, the team faces the challenge of efficiently importing types and classes across these divided entities. Traditional methods, such as package managers, are not optimal in this scenario due to their complexity and the additional maintenance they require. There is a need for a more agile and integrated solution that aligns with the dynamic nature of Booster Framework.\\n\\n## Proposed Solution\\n\\n### Introduction of `/inspect` Endpoint\\n\\n- **Functionality**: The `/inspect` endpoint in Booster services will provide direct access to `.d.ts` files of all project components, organized by agents. This will include types for commands, events, read-models, and other relevant components.\\n- **Benefits**: This endpoint simplifies development by offering an organized and up-to-date source of type definitions, ensuring consistency across different agents.\\n\\n### Extension of TypeScript Compiler\\n\\n- **Plugin Development**: A custom plugin for the TypeScript compiler will be developed to recognize a special import syntax, such as `import FooEvent from \'booster://agent-name/events/FooEvent\'`.\\n- **Dynamic Importing**: This plugin will dynamically fetch the corresponding `.d.ts` file from the `/inspect` endpoint, streamlining the import process.\\n- **Advantages**: This system allows seamless interaction between agents, enhancing the developer experience and negating the need for traditional package management complexities.\\n\\n## Addressing Potential Concerns\\n\\n### Security and Access Control for `/inspect`\\n\\n- **Implementation of Security Measures**: Appropriate security measures and access controls will be implemented to protect sensitive information within the `.d.ts` files accessible via the `/inspect` endpoint.\\n- **Restricted Access**: Access to the endpoint may be restricted based on user roles or project settings, ensuring that only authorized personnel can retrieve type definitions.\\n\\nAs the first version of this feature, these security concerns will be mitigated through making this feature opt-in. **It would be only available for environments where the flag has been enabled.** For example, it should be enabled in the local development, testing, and staging environments, but disabled in production.\\n\\n### Integration with Existing Workflow\\n\\n- **Seamless Integration**: The proposed solution is designed to integrate smoothly with the existing development workflow of the Booster Framework.\\n- **Addressing Challenges and Dependencies**: Potential challenges, such as network latency or downtime, will be addressed through robust error handling and fallback mechanisms.\\n\\n### Naming Convention and Format\\n\\n- **Import Syntax Convention**: The `booster://agent-name` import syntax will follow a clear and consistent naming convention, aligning with the overall structure and nomenclature of the Booster Framework.\\n- **Agent Naming Guidelines**: Specific guidelines and constraints for naming agents will be established to ensure clarity and avoid conflicts in the import process.\\n\\n## Conclusion\\n\\nThe introduction of the `/inspect` endpoint and the extension of the TypeScript compiler with a custom plugin represent a significant step forward in addressing the challenges of remote imports in Booster Framework. This solution not only simplifies the development process but also enhances the modularity and flexibility of the framework, ensuring a smooth and efficient experience for developers working across different agents and repositories."},{"id":"/0007-components","metadata":{"permalink":"/blog/0007-components","editUrl":"https://github.com/boostercloud/booster/edit/main/website/proposals/0007-components/index.mdx","source":"@site/proposals/0007-components/index.mdx","title":"BEEP 7 - Progressive component Integration Enhancement","description":"Introduction","date":"2024-01-31T00:00:00.000Z","formattedDate":"January 31, 2024","tags":[],"readingTime":6.685,"hasTruncateMarker":false,"authors":[{"name":"Nick Tchayka","title":"Booster Core Team","url":"https://github.com/NickSeagull","imageURL":"https://github.com/NickSeagull.png","key":"NickSeagull"}],"frontMatter":{"title":"BEEP 7 - Progressive component Integration Enhancement","authors":["NickSeagull"],"date":"2024-01-31T00:00"},"unlisted":false,"prevItem":{"title":"BEEP 6 - Remote Imports","permalink":"/blog/0006-remote-imports"}},"content":"import TerminalWindow from \'@site/src/components/TerminalWindow/TerminalWindow\'\\n\\n:::tip STATUS - DRAFT\\n:::\\n\\n## Introduction\\n\\nThis document proposes an enhancement to Booster Framework, introducing a new component integration mechanism. This enhancement aims not to overhaul the existing architecture but to provide an incremental upgrade, allowing the Framework to retain its current functionality while adding new, more efficient capabilities. This proposal details the transition to a system where components, written with clear interfaces using [Effect](https://www.effect.website/), can be directly injected into the Booster project, offering improved efficiency and customization.\\n\\n\\n:::warning\\n\\nThis component system is **not meant to be used by all Booster users**, but rather by it\'s **power users** who want to extend their apps in ways that are not possible with the current system, as well as **Booster contributors** who want to add new features to the framework.\\n\\n:::\\n\\n## Current Mechanism and Its Limitations\\n\\nThe Booster Framework currently relies on users specifying packages to be loaded (like Azure provider or filesystem components) in a JSON configuration, which are then **dynamically imported** by the framework. While functional, this approach has limitations in efficiency and customization.\\n\\n## Enhancement Overview\\n\\n### Interface Definition and Inversion of Control\\n\\n- **Interface Definition**: We propose to define explicit interfaces for CLI commands, runtime operations, and post-compile activities.\\n- **Inversion of Control**: Shift from dynamic imports to a system where users inject components directly into their Booster projects.\\n- **[Effect](https://www.effect.website/) Integration**: Utilize [Effect](https://www.effect.website/) for writing components, ensuring robustness and type safety.\\n  - This part is crucial, because it enhances the component system with:\\n    - **Dependency injection**: Components can be automatically injected into other components, allowing for a more modular design.\\n    - **Implicit structured logging and monitoring**: Components can log and monitor their own operations, and the framework can log and monitor the operations of the components.\\n    - **Better concurrency management**: Components can be run concurrently, and the framework can manage the concurrency of the components.\\n\\n### Maintaining Existing Functionality\\n\\n- **Gradual Transition**: The new system is designed to coexist with the current architecture, allowing users to transition at their own pace.\\n- **Backward Compatibility**: Ensures existing Booster applications continue to function without mandatory modifications.\\n\\n## Benefits\\n\\n- **Efficiency**: Reduces the overhead associated with dynamic imports.\\n- **Customization**: Offers users greater control over their applications.\\n- **Type Safety**: Enhances the robustness of applications through type-safe component development.\\n\\n## Design and Implementation\\n\\n:::warning\\n\\nThis is a draft of the design and implementation of the new component system. It is not final and is subject to change.\\nIt hasn\'t been tested against a compiler, tried in any way, let alone implemented. It is an \\"off the top of my head\\" design.\\n\\n:::\\n\\nThe key idea of the component system is to allow defining transient run-times, which allow specifying the behavior of a component during a specific run-time. We\'re writing run-time and not runtime, because a component can run during different moments that is not the runtime of an application.\\n\\nYou can think on this as the `npm` scripts that define the behavior of a package during different moments of the life of a package, like `preinstall`, `postinstall`, `prepublish`, etc. but for components.\\n\\nThe initial defined run-times are:\\n\\n- **CLI**: The component is executed during the execution of a CLI command.\\n- **Runtime**: The component is executed during the execution of the application.\\n- **Verification**: The component is executed after the compilation of the application. It is called verification, because at this point it allows us to perform additional validation and verification of the application.\\n\\nOf course, this list is not set in stone, and we can add more run-times in the future.\\n\\nBecause the component system is composable, it allows us to define components that are composed of other components. Here is when the run-times\\nbecome crucial. If a component uses another one, when a run-time of the parent component is triggered, the same run-time of the child component\\ngets triggered too. This is a bit of a tongue-twister, so let\'s take a look at a more concrete example.\\n\\n### Example: Event File Generation Component\\n\\nImagine we\'re defining a component called `EventGenerator` that allows us to generate files for events. Yes, this is an already existing feature of the framework, but\\nit will serve us an example.\\n\\nLet\'s assume that there\'s an already existing component called `FileGenerator` that allows writing an arbitrary string to a file that will be placed inside of the project `src` folder. This component would be defined like this (pseudocode):\\n\\n```ts\\n// This interface allows the users to provide different implementations for the components\\ninterface FileGenerator {\\n  generate(\\n    folder: string,\\n    filename: string,\\n    content: string\\n  ): Effect<...>\\n}\\n\\n// Concrete implementation for FileGenerator, could do whatever\\n// as long as it fulfills the contract of `FileGenerator`.\\n// Could be a mock one, a remote one, etc...\\nconst FileGenerator = defineComponent<FileGenerator>({\\n  // The actual method\\n  generate(folder, fileName, content) {\\n    // Here we specify that the block inside should only be executed during CLI-time\\n    during(RunTimes.CLI, () => {\\n      // ... actual code to generate the file\\n    })\\n  }\\n})\\n```\\n\\nNow, if we were to define the `EventGenerator` component, if we used `FileGenerator`. We wouldn\'t need to specify the CLI time, because that\'s\\nalready done at the `FileGenerator` component:\\n\\n```ts\\ninterface EventGenerator {\\n  generate(\\n    name: string,\\n    fields: Array<[string, string]>\\n  ): Effect<...>\\n}\\n\\nconst EventGenerator = defineComponent<EventGenerator>({\\n  // Effect.gen allows us to define custom async/await syntax that is extensible\\n  // instead of an async function we use a JS generator function,\\n  // and instead of await, we use the `_` helper and the `yield*` JS keyword.\\n  generate: (name, fields) => Effect.gen(function*(_){\\n    const content = ...// generate the content of the file\\n\\n    // We ask the dependency injection mechanism for the FileGenerator component\\n    const fileGen = yield* _(FileGenerator)\\n\\n    // We run the generate method in the file generator component\\n    yield* _(fileGen.generate(\\"events\\", `${name}.ts`, content))\\n  })\\n})\\n```\\n\\n:::info\\n\\nThe generator function might impress at first, but it is **regular JS syntax**, and it is a **1:1 mapping to async/await**. Even though it introduces\\na bit of friction, we believe that **the advantages outweight the friction by far**. You can check the\\n[**async/await comparison example on the Effect site**](https://www.effect.website/docs/essentials/using-generators#comparing-effectgen-with-asyncawait).\\n\\n:::\\n\\nIn the example above, we just used the `FileGenerator` component, and because that one already defined the CLI-time behavior, we didn\'t need to do\\nit ourselves.\\n\\nThis is an extremely powerful idea, because with a little subset of primitive components, we allow extending and customizing Booster apps in\\ninimaginable ways. Power users could define their own database component that allows them to configure, deploy and use a database in their app\\n**with a single function call.**\\n\\n### How to execute the different run-times?\\n\\nThese components would get injected into the `Booster.config` block for now, as it gets loaded when\\nthe application starts.\\n\\nIf a Booster application is configured with some components, it\'s main executable will get extended with an additional CLI flag `--exec` that\\nallows specifying the run-time to execute.\\n\\nTo maintain backwards compatibility, **if `--exec` is not specified, it will run the run-time by default**, as it is what happens when one runs a\\nBooster app nowadays.\\n\\nThis way of working allows taking responsibility out of the Booster CLI tool and allow users to create a regular `boost` (or any more descriptive name)\\nscript in their `package.json` file, allowing to execute the CLI components right with `pnpm` (or their preferred Node package manager):\\n\\n<TerminalWindow>\\n\\n```bash\\n$ pnpm boost event:generate --name AccountCreated --fields \'amount:number\'\\n```\\n\\n</TerminalWindow>\\n\\n## Considerations\\n\\n- **Compatibility Measures**: Ensure the new component system aligns with the existing Booster Framework.\\n- **Learning Curve**: Address the potential learning curve associated with [Effect](https://www.effect.website/) through detailed documentation and community support.\\n- **Error Handling**: Leverage TypeScript\'s compiler for improved error handling and runtime safety.\\n\\n## Conclusion\\n\\nThis proposal lays the groundwork for a progressive enhancement in Booster Framework\'s component integration mechanism. This proposal balances the need for advanced functionality and efficiency with the necessity of maintaining existing systems, while giving power users a great extensibility tool, and\\nmost importantly, increasing the robustness of the framework overall."}]}')}}]);