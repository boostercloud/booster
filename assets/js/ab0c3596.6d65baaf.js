"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8218],{7486:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var i=t(5893),o=t(1151),s=t(5163);const r={title:"BEEP 7 - Progressive component Integration Enhancement",authors:["NickSeagull"],date:"2024-01-31T00:00"},a=void 0,c={permalink:"/blog/0007-components",editUrl:"https://github.com/boostercloud/booster/edit/main/website/proposals/0007-components/index.mdx",source:"@site/proposals/0007-components/index.mdx",title:"BEEP 7 - Progressive component Integration Enhancement",description:"Introduction",date:"2024-01-31T00:00:00.000Z",formattedDate:"January 31, 2024",tags:[],readingTime:6.685,hasTruncateMarker:!1,authors:[{name:"Nick Tchayka",title:"Booster Core Team",url:"https://github.com/NickSeagull",imageURL:"https://github.com/NickSeagull.png",key:"NickSeagull"}],frontMatter:{title:"BEEP 7 - Progressive component Integration Enhancement",authors:["NickSeagull"],date:"2024-01-31T00:00"},unlisted:!1,prevItem:{title:"BEEP 6 - Remote Imports",permalink:"/blog/0006-remote-imports"}},l={authorsImageUrls:[void 0]},d=[{value:"Introduction",id:"introduction",level:2},{value:"Current Mechanism and Its Limitations",id:"current-mechanism-and-its-limitations",level:2},{value:"Enhancement Overview",id:"enhancement-overview",level:2},{value:"Interface Definition and Inversion of Control",id:"interface-definition-and-inversion-of-control",level:3},{value:"Maintaining Existing Functionality",id:"maintaining-existing-functionality",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Design and Implementation",id:"design-and-implementation",level:2},{value:"Example: Event File Generation Component",id:"example-event-file-generation-component",level:3},{value:"How to execute the different run-times?",id:"how-to-execute-the-different-run-times",level:3},{value:"Considerations",id:"considerations",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{title:"STATUS - DRAFT",type:"tip"}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["This document proposes an enhancement to Booster Framework, introducing a new component integration mechanism. This enhancement aims not to overhaul the existing architecture but to provide an incremental upgrade, allowing the Framework to retain its current functionality while adding new, more efficient capabilities. This proposal details the transition to a system where components, written with clear interfaces using ",(0,i.jsx)(n.a,{href:"https://www.effect.website/",children:"Effect"}),", can be directly injected into the Booster project, offering improved efficiency and customization."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["This component system is ",(0,i.jsx)(n.strong,{children:"not meant to be used by all Booster users"}),", but rather by it's ",(0,i.jsx)(n.strong,{children:"power users"})," who want to extend their apps in ways that are not possible with the current system, as well as ",(0,i.jsx)(n.strong,{children:"Booster contributors"})," who want to add new features to the framework."]})}),"\n",(0,i.jsx)(n.h2,{id:"current-mechanism-and-its-limitations",children:"Current Mechanism and Its Limitations"}),"\n",(0,i.jsxs)(n.p,{children:["The Booster Framework currently relies on users specifying packages to be loaded (like Azure provider or filesystem components) in a JSON configuration, which are then ",(0,i.jsx)(n.strong,{children:"dynamically imported"})," by the framework. While functional, this approach has limitations in efficiency and customization."]}),"\n",(0,i.jsx)(n.h2,{id:"enhancement-overview",children:"Enhancement Overview"}),"\n",(0,i.jsx)(n.h3,{id:"interface-definition-and-inversion-of-control",children:"Interface Definition and Inversion of Control"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Interface Definition"}),": We propose to define explicit interfaces for CLI commands, runtime operations, and post-compile activities."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Inversion of Control"}),": Shift from dynamic imports to a system where users inject components directly into their Booster projects."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.a,{href:"https://www.effect.website/",children:"Effect"})," Integration"]}),": Utilize ",(0,i.jsx)(n.a,{href:"https://www.effect.website/",children:"Effect"})," for writing components, ensuring robustness and type safety.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This part is crucial, because it enhances the component system with:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dependency injection"}),": Components can be automatically injected into other components, allowing for a more modular design."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Implicit structured logging and monitoring"}),": Components can log and monitor their own operations, and the framework can log and monitor the operations of the components."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Better concurrency management"}),": Components can be run concurrently, and the framework can manage the concurrency of the components."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"maintaining-existing-functionality",children:"Maintaining Existing Functionality"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Gradual Transition"}),": The new system is designed to coexist with the current architecture, allowing users to transition at their own pace."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backward Compatibility"}),": Ensures existing Booster applications continue to function without mandatory modifications."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"benefits",children:"Benefits"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficiency"}),": Reduces the overhead associated with dynamic imports."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Customization"}),": Offers users greater control over their applications."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Safety"}),": Enhances the robustness of applications through type-safe component development."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"design-and-implementation",children:"Design and Implementation"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:'This is a draft of the design and implementation of the new component system. It is not final and is subject to change.\nIt hasn\'t been tested against a compiler, tried in any way, let alone implemented. It is an "off the top of my head" design.'})}),"\n",(0,i.jsx)(n.p,{children:"The key idea of the component system is to allow defining transient run-times, which allow specifying the behavior of a component during a specific run-time. We're writing run-time and not runtime, because a component can run during different moments that is not the runtime of an application."}),"\n",(0,i.jsxs)(n.p,{children:["You can think on this as the ",(0,i.jsx)(n.code,{children:"npm"})," scripts that define the behavior of a package during different moments of the life of a package, like ",(0,i.jsx)(n.code,{children:"preinstall"}),", ",(0,i.jsx)(n.code,{children:"postinstall"}),", ",(0,i.jsx)(n.code,{children:"prepublish"}),", etc. but for components."]}),"\n",(0,i.jsx)(n.p,{children:"The initial defined run-times are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CLI"}),": The component is executed during the execution of a CLI command."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime"}),": The component is executed during the execution of the application."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Verification"}),": The component is executed after the compilation of the application. It is called verification, because at this point it allows us to perform additional validation and verification of the application."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Of course, this list is not set in stone, and we can add more run-times in the future."}),"\n",(0,i.jsx)(n.p,{children:"Because the component system is composable, it allows us to define components that are composed of other components. Here is when the run-times\nbecome crucial. If a component uses another one, when a run-time of the parent component is triggered, the same run-time of the child component\ngets triggered too. This is a bit of a tongue-twister, so let's take a look at a more concrete example."}),"\n",(0,i.jsx)(n.h3,{id:"example-event-file-generation-component",children:"Example: Event File Generation Component"}),"\n",(0,i.jsxs)(n.p,{children:["Imagine we're defining a component called ",(0,i.jsx)(n.code,{children:"EventGenerator"})," that allows us to generate files for events. Yes, this is an already existing feature of the framework, but\nit will serve us an example."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's assume that there's an already existing component called ",(0,i.jsx)(n.code,{children:"FileGenerator"})," that allows writing an arbitrary string to a file that will be placed inside of the project ",(0,i.jsx)(n.code,{children:"src"})," folder. This component would be defined like this (pseudocode):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// This interface allows the users to provide different implementations for the components\ninterface FileGenerator {\n  generate(\n    folder: string,\n    filename: string,\n    content: string\n  ): Effect<...>\n}\n\n// Concrete implementation for FileGenerator, could do whatever\n// as long as it fulfills the contract of `FileGenerator`.\n// Could be a mock one, a remote one, etc...\nconst FileGenerator = defineComponent<FileGenerator>({\n  // The actual method\n  generate(folder, fileName, content) {\n    // Here we specify that the block inside should only be executed during CLI-time\n    during(RunTimes.CLI, () => {\n      // ... actual code to generate the file\n    })\n  }\n})\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, if we were to define the ",(0,i.jsx)(n.code,{children:"EventGenerator"})," component, if we used ",(0,i.jsx)(n.code,{children:"FileGenerator"}),". We wouldn't need to specify the CLI time, because that's\nalready done at the ",(0,i.jsx)(n.code,{children:"FileGenerator"})," component:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'interface EventGenerator {\n  generate(\n    name: string,\n    fields: Array<[string, string]>\n  ): Effect<...>\n}\n\nconst EventGenerator = defineComponent<EventGenerator>({\n  // Effect.gen allows us to define custom async/await syntax that is extensible\n  // instead of an async function we use a JS generator function,\n  // and instead of await, we use the `_` helper and the `yield*` JS keyword.\n  generate: (name, fields) => Effect.gen(function*(_){\n    const content = ...// generate the content of the file\n\n    // We ask the dependency injection mechanism for the FileGenerator component\n    const fileGen = yield* _(FileGenerator)\n\n    // We run the generate method in the file generator component\n    yield* _(fileGen.generate("events", `${name}.ts`, content))\n  })\n})\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The generator function might impress at first, but it is ",(0,i.jsx)(n.strong,{children:"regular JS syntax"}),", and it is a ",(0,i.jsx)(n.strong,{children:"1:1 mapping to async/await"}),". Even though it introduces\na bit of friction, we believe that ",(0,i.jsx)(n.strong,{children:"the advantages outweight the friction by far"}),". You can check the\n",(0,i.jsx)(n.a,{href:"https://www.effect.website/docs/essentials/using-generators#comparing-effectgen-with-asyncawait",children:(0,i.jsx)(n.strong,{children:"async/await comparison example on the Effect site"})}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, we just used the ",(0,i.jsx)(n.code,{children:"FileGenerator"})," component, and because that one already defined the CLI-time behavior, we didn't need to do\nit ourselves."]}),"\n",(0,i.jsxs)(n.p,{children:["This is an extremely powerful idea, because with a little subset of primitive components, we allow extending and customizing Booster apps in\ninimaginable ways. Power users could define their own database component that allows them to configure, deploy and use a database in their app\n",(0,i.jsx)(n.strong,{children:"with a single function call."})]}),"\n",(0,i.jsx)(n.h3,{id:"how-to-execute-the-different-run-times",children:"How to execute the different run-times?"}),"\n",(0,i.jsxs)(n.p,{children:["These components would get injected into the ",(0,i.jsx)(n.code,{children:"Booster.config"})," block for now, as it gets loaded when\nthe application starts."]}),"\n",(0,i.jsxs)(n.p,{children:["If a Booster application is configured with some components, it's main executable will get extended with an additional CLI flag ",(0,i.jsx)(n.code,{children:"--exec"})," that\nallows specifying the run-time to execute."]}),"\n",(0,i.jsxs)(n.p,{children:["To maintain backwards compatibility, ",(0,i.jsxs)(n.strong,{children:["if ",(0,i.jsx)(n.code,{children:"--exec"})," is not specified, it will run the run-time by default"]}),", as it is what happens when one runs a\nBooster app nowadays."]}),"\n",(0,i.jsxs)(n.p,{children:["This way of working allows taking responsibility out of the Booster CLI tool and allow users to create a regular ",(0,i.jsx)(n.code,{children:"boost"})," (or any more descriptive name)\nscript in their ",(0,i.jsx)(n.code,{children:"package.json"})," file, allowing to execute the CLI components right with ",(0,i.jsx)(n.code,{children:"pnpm"})," (or their preferred Node package manager):"]}),"\n",(0,i.jsx)(s.Z,{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ pnpm boost event:generate --name AccountCreated --fields 'amount:number'\n"})})}),"\n",(0,i.jsx)(n.h2,{id:"considerations",children:"Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compatibility Measures"}),": Ensure the new component system aligns with the existing Booster Framework."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Learning Curve"}),": Address the potential learning curve associated with ",(0,i.jsx)(n.a,{href:"https://www.effect.website/",children:"Effect"})," through detailed documentation and community support."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Leverage TypeScript's compiler for improved error handling and runtime safety."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"This proposal lays the groundwork for a progressive enhancement in Booster Framework's component integration mechanism. This proposal balances the need for advanced functionality and efficiency with the necessity of maintaining existing systems, while giving power users a great extensibility tool, and\nmost importantly, increasing the robustness of the framework overall."})]})}function m(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},5163:(e,n,t)=>{t.d(n,{Z:()=>s});t(7294);const i={terminalWindow:"terminalWindow_wGrl",terminalWindowHeader:"terminalWindowHeader_o9Cs",row:"row_Rn7G",buttons:"buttons_IGLB",right:"right_fWp9",terminalWindowAddressBar:"terminalWindowAddressBar_X8fO",dot:"dot_fGZE",terminalWindowMenuIcon:"terminalWindowMenuIcon_rtOE",bar:"bar_Ck8N",terminalWindowBody:"terminalWindowBody_tzdS"};var o=t(5893);function s(e){let{children:n}=e;return(0,o.jsxs)("div",{className:i.terminalWindow,children:[(0,o.jsx)("div",{className:i.terminalWindowHeader,children:(0,o.jsxs)("div",{className:i.buttons,children:[(0,o.jsx)("span",{className:i.dot,style:{background:"#f25f58"}}),(0,o.jsx)("span",{className:i.dot,style:{background:"#fbbe3c"}}),(0,o.jsx)("span",{className:i.dot,style:{background:"#58cb42"}})]})}),(0,o.jsx)("div",{className:i.terminalWindowBody,children:n})]})}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>r});var i=t(7294);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);